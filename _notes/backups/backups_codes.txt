// pipe ok - async que conseguiu capturar mensagem de erro - todo: só nao passou o tipo erro apra poder pegar o statuscode 400 do obj erro.

const pipecaseCreateClienteFisico = async (target: ArgsClienteFisico) => {
  return await listFeatArgsClienteFisico.reduce(async (acc: any, fn) => {
    try {
      return await fn(acc)
    }
    catch (err: any) {
      return err.message
    }
  }, target)
}

---

// tentando pipe para validar e criar entity - resultado: nao deu certo ao estourar erro no pipe usado em createClienteFisico
```
// -- pipe caseCreateClientefisico - troquei este que funcionou pela lib pipeGeneric :
const pipecaseCreateClienteFisico = async (target: ArgsClienteFisico) => {
  return listFeatArgsClienteFisico.reduce((acc: any, fn) => fn(acc), target)
}
```

---
// Pipe sem reduce - feitos dentro da funcao -- useCreateClienteFisico --
// è o que deu certo porque o reduce nao to conseguindo capturar o erro e passa-lo pra frente pra continuar a captura pela proxima camada que vai usar que é a de controlle.

import {
  validateFieldsArgsClienteFisico,
  createFactoryClienteFisico,
} from "@clienteFisico";

const pipecaseCreateClienteFisico = async (args: ArgsClienteFisico) => {
  const valid = await validateFieldsArgsClienteFisico(args)
  const factory = await createFactoryClienteFisico(valid)
  return await factory
}

// pipe usando pipeGeneric replicasRemote
const pipecaseCreateClienteFisico = async (argTarget: ArgsClienteFisico) => await PipeGeneric<ArgsClienteFisico, ArgsClienteFisico>(argTarget, listFeatArgsClienteFisico)
